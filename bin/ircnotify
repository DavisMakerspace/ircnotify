#!/usr/bin/env ruby

require 'cinch'
require 'socket'
require 'json'
require 'etc'

module IRCNotify
  extend self

  NAME = File.basename $0
  VERSION = %x{cd #{File.dirname $0} && git describe --dirty=-modified}.strip
  HOST = Socket.gethostbyname(Socket.gethostname).first

  config = ARGV.shift || File.join(File.dirname($0), "..", "etc", "config")
  if not File.exists? config
    STDERR.puts "Can't find config file #{config}"
    STDERR.puts "Either create it or specify another config file with: #{File.basename $0} [filename]"
    exit
  end
  config_wrapper = "module Config\n%s\nend"
  module_eval config_wrapper % File.read(config), File.realpath(config), 0
  module_eval config_wrapper % File.read(File.join(File.dirname($0), "..", "share", "config.schema"))

  class Server
    def initialize bridge
      @bridge = bridge
      if File.socket? Config::Server::PATH then File.delete Config::Server::PATH end
      @unix_server = UNIXServer.new Config::Server::PATH
      @clients = []
    end
    def start 
      while socket = @unix_server.accept do
        client = Client.new @bridge, socket
        Thread.new do
          @clients << client
          begin
            client.start_read
          rescue StandardError => error
            IRCNotify.log "Client error: #{error}", :error
          end
          @clients.delete client
        end
      end
    end
    def stop
      path = @unix_server.path
      @unix_server.shutdown
      @unix_server = nil
      File.delete path
    end
    def send at, from, cmd
      trigger, msg = cmd.split ' ', 2
      if trigger
        @clients.each do |c| c.send at, from, trigger, msg end
      else
        @bridge.irc_send NAME, "#{VERSION} listening on #{HOST}:#{@unix_server.path}"
      end
    end
  end

  class Client
    def initialize bridge, socket
      @bridge = bridge
      @socket = socket
      @peername = Etc.getpwuid(@socket.getpeereid[0]).name
      @name = @peername
      @triggers = []
      @targets = nil
      IRCNotify.log "New connection #{@socket} by #{@peername}"
    end
    def start_read
      @socket.each do |line|
        IRCNotify.log "Client #{@socket} got: #{line.strip}", :debug
        cmds = {}
        if line.start_with? "{"
          begin
            cmds = JSON::parse line
          rescue JSON::ParserError => error
            IRCNotify.log "Could not parse presumed JSON string: #{line}", :error
            IRCNotify.log "got error #{error}", :error
            cmds = {}
          end
        else
          cmds['send'] = line.strip
        end
        handle_commands cmds
      end
      IRCNotify.log "Ending connection #{@socket}"
      @socket = nil
    end
    def send at, from, trigger, msg
      if @triggers.include? trigger
        data = {
          at: at.object_id,
          at_name: at.name,
          from: from.object_id,
          from_name: from.name,
          trigger: trigger,
          msg: msg}
        @socket.write(data.to_json + "\r\n")
      end
    end
    def handle_commands cmds
      @name = cmds['set_name'].to_s if cmds['set_name']
      if cmds['set_targets'] then @targets = Array.try_convert cmds['set_targets'] || nil end
      targets = Array.try_convert cmds['targets'] || @targets
      if cmds['set_triggers'] then @triggers = Array.try_convert cmds['set_triggers'] || [] end
      if cmds['send'] then @bridge.irc_send @name, cmds['send'], targets end
    end
  end

  class IRC
    def initialize bridge
      @bridge = bridge
      @known_targets = {}
      @bot = Cinch::Bot.new
      @bot.configure do |c|
        c.user = File.basename $0
        c.realname = c.user
        c.nick = Config::IRC::NICK
        c.server = Config::IRC::SERVER
        c.port = Config::IRC::PORT
        c.channels = Config::IRC::CHANNELS
      end
      @bot.on :connect, //, self do |m, irc| irc.connected end
      @bot.on :private, //, self do |m, irc| if m.command == "PRIVMSG" then irc.received m, m.message end end
      if Config::IRC::CMDPREFIX
        @bot.on :channel, /^#{Config::IRC::CMDPREFIX} *(.*)/, self do |m, irc, cmd| irc.received m, cmd end
      end
    end
    def connected
      @bot.on :channel, /^#{@bot.nick}(?:[:, ] *(.*)|$)/, self do |m, irc, cmd| irc.received m, cmd end
    end
    def received msg, cmd
      @known_targets[msg.target.object_id] = msg.target
      @known_targets[msg.user.object_id] = msg.user
      @bridge.server_send msg.target, msg.user, cmd
    end
    def send src, msg, target_ids
      if target_ids
        targets = target_ids.map do |tid| @known_targets[tid] end
        targets.compact!
      else
        targets = @bot.channels
      end
      targets.each {|channel| channel.send (Config::IRC::MSGFORMAT % {src: src, msg: msg})}
    end
    def get_target id
      @known_targets[id]
    end
    def log msg, level
      @bot.log msg, level
    end
    def start
      @bot.start
    end
  end

  class Bridge
    def initialize
      @server = Server.new self
      @irc = IRC.new self
    end
    def server_send target, user, cmd
      @server.send target, user, cmd
    end
    def irc_send src, msg, target_ids=nil
      @irc.send src, msg, target_ids
    end
    def start
      threads = []
      threads << Thread.new {@server.start}
      threads << Thread.new {@irc.start}
      threads.each {|t| t.join}
    end
    def log msg, level
      @irc.log msg, level
    end
  end

  def start
    @bridge = Bridge.new
    @bridge.start
  end
  def log msg, level=:info
    @bridge.log msg, level
  end
end

IRCNotify.start
